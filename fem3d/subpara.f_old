c
c Paralution solver routines
c
c revision log :
c
c 27.11.2015    mbj     First version
c
c*************************************************************************

      subroutine para_init_system

! Initialize vector and matrix      

	use mod_system
	use basin

      implicit none
      include 'param.h'

      integer n

      integer icall_coo
      data icall_coo /0/
      save icall_coo

      do n=1,nkn
         rvec(n) = 0.
         raux(n) = 0.
      end do

      if (icall_coo.eq.0) then		! only first time
	 write(6,*) 'SOLVER: Paralution'
         call coo_init(nel,nkn,mbw,nen3v,csrdim,nnzero,ijp,icoo,jcoo)
         print*, 'coo-matrix initialisation...'
         print*, 'Number of non-zeros: ',nnzero
         icall_coo=1
      end if

      do n=1,nnzero
         coo(n) = 0.
      end do

      end

c*************************************************************************

      subroutine para_solve_system(n)

! Solver routine with Paralution iterative methods.

      use mod_system
      use, intrinsic :: ISO_C_BINDING, only : C_INT, C_PTR, C_DOUBLE, C_CHAR, C_NULL_CHAR, C_LOC

      implicit none

      integer, intent(in) :: n

      real*8, allocatable :: csr(:)
      integer, allocatable :: icsr(:),jcsr(:)
      integer, allocatable :: iwork(:)

      logical iscoo

      ! Paralution parameters
      character(len=80) :: Solver,Op_mat_form,Prec,Prec_mat_form
      integer iter ! number of iterations needed to converge
      double precision resnorm ! final residual norm
      integer stat ! status code

      iscoo = .true.

!--------------------------------------------------
! Sparskit is set to use Incomplete LU factorization as preconditioner and
! bcgstab as solver
!--------------------------------------------------

      if( iscoo ) then	!use coo matrix

        ! Solver (CG,BiCGStab,GMRES,Fixed-Point)
        Solver = 'BiCGStab'
        Solver = 'GMRES'	!default
        ! Operation matrix format(DENSE,CSR,MCSR,COO,DIA,ELL,HYB)
        Op_mat_form = 'HYB'	!default
        ! Preconditioner (None,Jacobi,MultiColoredGS,MultiColoredSGS,ILU,MultiColoredILU)
        Prec = 'MultiColoredILU'	!default
        ! Preconditioner matrix format (DENSE,CSR,MCSR,COO,DIA,ELL,HYB)
        Prec_mat_form = 'ELL'	!default

        call paralution_fortran_solve_coo(
     +       n,n,nnzero,	! Number of rows, number of columns, number of non-zero elements
     +       trim(solver),
     +       trim(Op_mat_form),
     +       trim(Prec),
     +       trim(Prec_mat_form),
     +       icoo, jcoo, coo, rvec, !Row index (COO) or row offset pointer (CSR), column index, right-hand side
     +       1d-10, 1d-6, 1d+8, 2000, !Abs tol, rel tol, div tol, max n of iter
     +       30, 0, 1, !Size of the Krylov subspace (GMRES), ILU(p), ILU(q)
     +       raux, iter, resnorm, stat) ! output

      else

        ! convert coo to csr and sort
        allocate(csr(csrdim),icsr(n+1),jcsr(csrdim),iwork(2*csrdim))
        call coocsr(n,nnzero,coo,icoo,jcoo,csr,jcsr,icsr)
        if( nnzero .gt. csrdim .or. n+1 .gt. 2*csrdim ) goto 99
        call csort (n,csr,jcsr,icsr,iwork,.true.)

        ! Solver (CG,BiCGStab,GMRES,Fixed-Point)
        Solver = 'BiCGStab'
        Solver = 'CG'	!default
        ! Operation matrix format(DENSE,CSR,MCSR,COO,DIA,ELL,HYB)
        Op_mat_form = 'CSR'	!default
        ! Preconditioner (None,Jacobi,MultiColoredGS,MultiColoredSGS,ILU,MultiColoredILU)
        Prec = 'MultiColoredSGS'	!default
        ! Preconditioner matrix format (DENSE,CSR,MCSR,COO,DIA,ELL,HYB)
        Prec_mat_form = 'CSR'	!default

        call paralution_fortran_solve_csr(
     +       n,n,nnzero,	! Number of rows, number of columns, number of non-zero elements
     +       trim(solver),
     +       trim(Op_mat_form),
     +       trim(Prec),
     +       trim(Prec_mat_form),
     +       icsr, jcsr, csr, rvec, !Row index (COO) or row offset pointer (CSR), column index, right-hand side
     +       1d-10, 1d-6, 1d+8, 2000, !Abs tol, rel tol, div tol, max n of iter
     +       0, 0, 1, !Size of the Krylov subspace (GMRES), ILU(p), ILU(q)
     +       raux, iter, resnorm, stat) ! output

      deallocate(csr,icsr,jcsr,iwork)

      end if

!-----------------------------------------------------------------
      rvec = raux

      return
   99	continue
      write(6,*) nnzero,n+1,csrdim
      stop 'error stop para_solve_system: dimension iwork'

      end subroutine para_solve_system

c*************************************************************************
